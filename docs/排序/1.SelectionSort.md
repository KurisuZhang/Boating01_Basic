# Selection Sort

![01.gif](/Users/lin/Desktop/Github/Boating01_Basic/docs/排序/image/01.gif)

|                | Best     | Average  | Worst    |
| -------------- |:--------:|:--------:|:--------:|
| Selection sort | Ω($n^2$) | θ($n^2$) | O($n^2$) |

## 实现

```java
    public static <E extends Comparable<E>> void sort(E[] arr){

        for(int i = 0; i < arr.length; i ++){

            // 选择 arr[i...n) 中的最小值
            int minIndex = i;
            for(int j = i; j < arr.length; j ++){
                // 比较arr[j] 和 arr[minIndex], 将最小值的index存入minindex
                if(arr[j].compareTo(arr[minIndex]) < 0){
                    minIndex = j;
                }
            }

            // swap
            E tem = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = tem;
        }
    }
```

## 测试代码

```java
import java.lang.reflect.Method;

public class SortingHelper {

    private SortingHelper(){}

    public static <E extends Comparable<E>> boolean isSorted(E[] arr){
        for(int i = 1; i < arr.length; i ++)
            if(arr[i - 1].compareTo(arr[i]) > 0)
                return false;
        return true;
    }

    public static <E extends Comparable<E>> void sortTest(String className, E[] arr) throws Exception {
        // 反射机制
        Class<?> cls = Class.forName(className);
        Object newInstance = cls.newInstance();
        Method method = cls.getMethod("sort", Comparable[].class);
        // 测试时间
        long startTime = System.nanoTime();
        method.invoke(newInstance, (Object) arr);
        long endTime = System.nanoTime();
        double time = (endTime - startTime) / 1000000000.0;
        // 测试是否正确
        if(!SortingHelper.isSorted(arr))
            throw new RuntimeException(className + " failed");
        System.out.printf("%s , n = %d : %f s%n", className, arr.length, time);
    }
}
```
